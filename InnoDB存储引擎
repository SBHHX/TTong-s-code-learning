-- InnoDB存储引擎


-- 这张图片介绍了InnoDB存储引擎的逻辑存储结构，具体如下：
/*- **表空间**：以`.ibd`文件形式存在，一个MySQL实例可对应多个表空间，用于存储记录、索引等数据，是数据存储的外层逻辑结构。
- **段**：分为数据段（对应B+树叶子节点，存储实际数据）、索引段（对应B+树非叶子节点，存储索引信息）、回滚段（用于事务回滚操作）。段负责管理多个区，是
  表空间内对数据和索引进行组织管理的逻辑单元。
- **区（Extent）**：表空间的单元结构，每个区大小固定为1MB 。默认InnoDB页大小为16KB，所以一个区包含64个连续的页，是数据存储和分配的基本单位之一。
- **页（Page）**：InnoDB磁盘管理的最小单元，默认大小16KB。为保证页的连续性，InnoDB每次从磁盘申请4 - 5个区，数据以页为单位进行读取和写入。
- **行（Row）**：InnoDB按行存放数据，每行记录除用户定义的列外，还包含隐藏列`trx_id`（记录修改事务的ID）和`roll_pointer`（指向该记录修改前在
  undo日志中的版本，用于实现事务的回滚和MVCC多版本并发控制） 。 */


-- 这张图展示了InnoDB存储引擎的架构，包括内存结构和磁盘结构两部分：
/*- **内存结构**：
    - **缓冲池（Buffer Pool）**：是InnoDB最重要的内存组件，用于缓存表数据和索引数据，加速数据的读写操作。通过自适应哈希索引（Adaptive Hash Index）
      可以快速定位缓冲池中的数据。
    - **更改缓冲区（Change Buffer）**：当对非唯一二级索引进行写操作（如插入、删除、更新）时，如果对应的索引页不在缓冲池中，不会立即从磁盘读取，而
      是将更改操作缓存到更改缓冲区，等未来数据被读取时再合并应用，减少磁盘I/O。
    - **日志缓冲区（Log Buffer）**：用于暂存重做日志（Redo Log）信息，先将重做日志写入日志缓冲区，再定期或满足一定条件时刷新到磁盘上的重做日志文
       件中，保证事务的持久性。
- **磁盘结构**：
    - **系统表空间（System Tablespace）**：默认文件名为`ibdata1`，存储了系统元数据、内部数据字典等信息，还包含更改缓冲区（Change Buffer）。
    - **独立表空间（File-Per-Table Tablespaces）**：当`innodb_file_per_table=ON`时启用，每个表的数据和索引都存储在独立的`.ibd`文件中，便于管理和维护，如`t1.ibd`、`t2.ibd`。
    - **通用表空间（General Tablespaces）**：可以将多个表的数据存储在同一个表空间中，由多个文件组成，如`ts1.ibd`等。
    - **撤销表空间（Undo Tablespaces）**：包含系统撤销表空间（如`undo_002`）和用户定义的撤销表空间（如`undo_003.ibu`、`undo_004.ibu`），用于存储撤销日志，实现事务回滚和多版本并发控制（MVCC）。
    - **双写缓冲区文件（Doublewrite Buffer Files）**：如`ib_16384_0.dblwr`、`ib_16384_1.dblwr`，在将数据页从缓冲池刷新到磁盘时，先写入双写缓冲区，再写入数据文件，防止部分写失败导致数据损坏。
    - **重做日志文件（Redo Log）**：如`ib_logfile0`、`ib_logfile1`，记录事务对数据的修改操作，用于在数据库崩溃后恢复数据，保证事务的持久性。
    - **临时表空间（Temporary Tablespaces）**：用于存储临时表和排序等操作产生的临时数据，包含全局临时表空间（如`ibtmp1`）和会话级临时表空间（如`temo_1.ibt`、`temo_2.ibt`等）。 */


-- 这张图片介绍了InnoDB存储引擎的内存架构，重点讲解了缓冲池（Buffer Pool）的相关知识：
/*- **缓冲池的作用**：缓冲池是主内存中的区域，用于缓存磁盘上经常被操作的真实数据。在执行增删改查操作时，优先操作缓冲池中的数据。若缓冲池中没有所需数据，则从磁盘加载并缓存，之后以一定频率将修改后的数据刷新到磁盘，减少磁盘I/O操作，加快数据处理速度。
- **缓冲池的管理单位与数据结构**：缓冲池以页（Page）为单位，底层使用链表数据结构来管理这些页。通过这种方式，可以方便地对页进行添加、删除和查找等操作。
- **页的类型**：
    - **free page（空闲页）**：尚未被使用的页，可用于存储新的数据。
    - **clean page（干净页）**：已被使用，但数据未被修改过的页，其数据与磁盘上的数据一致。
    - **dirty page（脏页）**：已被使用且数据被修改过的页，此时页中的数据与磁盘数据不一致，需要在合适的时候将其刷新到磁盘以保持数据一致性。 */



-- 这张图片继续介绍了InnoDB存储引擎内存架构中更改缓冲区（Change Buffer）的相关知识，包括其工作机制和意义：
/*- **更改缓冲区的工作机制**：更改缓冲区主要针对非唯一二级索引页。当执行数据操纵语言（DML）语句（如插入、删除、更新）时，如果涉及的相关数据页不在缓冲
     池（Buffer Pool）中，不会直接去操作磁盘，而是将数据变更暂存到更改缓冲区中。在未来这些数据被读取时，再将更改缓冲区中的数据与原数据合并，恢复到缓冲池
     中，之后再将合并后的数据刷新到磁盘上。
- **更改缓冲区的意义**：二级索引通常具有非唯一性，并且插入顺序相对随机，删除和更新操作也可能影响索引树中不相邻的部分。若每次相关操作都直接操作磁盘，
    会产生大量磁盘I/O。而有了更改缓冲区后，可以先在缓冲池中对这些变更进行合并处理，减少直接对磁盘的操作次数，从而降低磁盘I/O开销，提升数据库性能。 */


-- 这张图片介绍了InnoDB存储引擎内存架构中的自适应哈希索引（Adaptive Hash Index）：
/*- **作用**：用于优化对缓冲池（Buffer Pool）中数据的查询。通过建立哈希索引，能加快数据的查找速度，减少查询时的时间开销。
- **创建机制**：InnoDB存储引擎会监控对表上各索引页的查询情况。当系统检测到使用哈希索引能够显著提升查询速度时，就会自动建立哈希索引，即自适应哈希索引。
  这个过程不需要人工干预，是系统根据实际的查询负载和数据访问模式动态完成的。
- **相关参数**：与自适应哈希索引相关的参数是`adaptive_hash_index` ，通过该参数可以对自适应哈希索引的相关行为进行配置（例如开启或关闭等），不过在
  大多数情况下，保持默认设置即可让InnoDB根据实际情况灵活运用自适应哈希索引来优化性能。
*/

-- 查询自适应哈希是否开启
    show variables like '%hash_index';


-- 这张图片介绍了InnoDB存储引擎内存架构中日志缓冲区（Log Buffer）的功能、默认大小、调整意义以及相关参数：
/*- **功能**：日志缓冲区用于暂存重做日志（redo log）和撤销日志（undo log），这些日志后续会定期刷新到磁盘，减少磁盘I/O操作。
- **默认大小与调整**：默认大小是16MB。当事务涉及大量更新、插入或删除操作时，增大日志缓冲区可容纳更多日志，减少刷新磁盘的频率，节省磁盘I/O。
- **相关参数**：
    - `innodb_log_buffer_size`：用来设置日志缓冲区的大小。
    - `innodb_flush_log_at_trx_commit`：控制日志刷新到磁盘的时机，不同取值含义为：
        - **1**：每次事务提交，日志都写入并刷新到磁盘，数据一致性最高，但性能相对低。
        - **0**：每秒将日志写入并刷新到磁盘一次，性能较好，但系统崩溃时可能丢失1秒内的日志数据。
        - **2**：每次事务提交后写入日志，每秒刷新到磁盘一次，性能和数据一致性较为平衡 。 */

-- 查看缓冲区大小
show variables like '%log_buffer_size%';

-- 查看日志刷新时机
show variables like '%flush_log%';
-- 1：每次事务提交，日志都写入并刷新到磁盘，数据一致性最高，但性能相对低。
-- 0：每秒将日志写入并刷新到磁盘一次，性能较好，但系统崩溃时可能丢失1秒内的日志数据。
-- 2：每次事务提交后写入日志，每秒刷新到磁盘一次，性能和数据一致性较为平衡 。



-- 架构 磁盘结构
/*这张图片介绍了InnoDB存储引擎的磁盘结构，包含以下几种主要的表空间及相关文件：
- **系统表空间（System Tablespace）**：文件名为`ibdata1`，是更改缓冲区的存储区域。若表在系统表空间创建，还可能包含表和索引数据。在MySQL 5.x版
  本中，还存有InnoDB数据字典、undo日志等。可通过参数`innodb_data_file_path`配置其相关属性。

- **独立表空间（File-Per-Table Tablespaces）**：当`innodb_file_per_table=ON`时启用，每个InnoDB表的数据和索引存储在单独数据文件
  （如`t1.ibd`、`t2.ibd`）中，便于管理和维护。可通过`innodb_file_per_table`参数开启或关闭此模式。

- **通用表空间（General Tablespaces）**：
  1.创建方式**：使用`CREATE TABLESPACE`语句创建通用表空间，语法为`CREATE TABLESPACE xxxx ADD DATAFILE 'file_name' ENGINE = engine_name;`
    其中`xxxx`是自定义的表空间名称，`file_name`指定数据文件名称（包含路径），`engine_name`通常为`innodb`（InnoDB存储引擎）。
  2.使用方法**：创建表时，可以指定表存储在已创建的通用表空间中，便于对多个表的数据进行统一管理，以及灵活分配存储空间 。CREATE TABLE XXX... TABLESPACE ts_name,

- **撤销表空间**：MySQL实例初始化时，会自动创建两个默认的撤销表空间，初始大小为16M，主要用于存储撤销日志（undo log）。撤销日志在事务回滚、多版本
  并发控制（MVCC）等场景中发挥作用，比如事务执行过程中对数据进行修改前，旧版本的数据会被记录到undo log中，以便在需要回滚事务时恢复数据。

- **临时表空间**：InnoDB使用会话临时表空间和全局临时表空间，用于存储用户创建的临时表数据，以及在排序、去重等操作过程中产生的临时数据。不同会话的临
  时数据可以存储在会话临时表空间中，而全局临时表空间则可以为多个会话提供临时数据存储服务 。

- **双写缓冲区文件**：InnoDB引擎在将数据页从缓冲池（Buffer Pool）刷新到磁盘之前，会先把数据页写入双写缓冲区文件（如`#ib_16384_0.dblwr`、`#ib_16384_1.dblwr` ）。
  当系统出现异常，如断电、崩溃等情况时，若数据页在写入磁盘过程中发生部分写失败，就可以从双写缓冲区中恢复数据，保证数据的完整性。

- **重做日志**：用于实现事务的持久性。由重做日志缓冲区（redo log buffer，位于内存中）和重做日志文件（redo log，位于磁盘中）两部分组成。事务提交时，
  事务对数据的所有修改信息会存储到重做日志中。在刷新脏页（被修改过但未同步到磁盘的数据页）到磁盘过程中，如果出现错误，就可以利用重做日志中的信息来恢复数据，
  确保事务提交的数据不会丢失 。
*/



-- 查看参数
show variables like '%data_file_path%';
-- ibdata1：系统表空间

-- 查看独立表空间文件是否开启
show variables like '%file_per_table%';
-- ON:代表每一张表都会生成对应的表空间文件  .ibd   存放表结构，文件，索引

-- 创建通用表空间
create tablespace ts_itheima add datafile 'myitheima.ibd' engine = innodb;

-- 创建表时指定存放文件位置
create table a(id int primary key auto_increment,name varchar(10)) engine = innodb tablespace ts_itheima;




-- 后台线程架构：
/*- **Master Thre这张图片介绍了InnoDB存储ad（主线程）**：是核心后台线程，负责调度其他线程的工作。同时，它会将缓冲池中的数据异步刷新到磁盘，维持数
    据一致性，具体任务有脏页刷新、合并插入缓存、回收undo页等，对数据库的整体性能和数据一致性保障至关重要。

  - **IO Thread（IO线程）**：InnoDB大量采用异步I/O（AIO）处理IO请求以提升性能，IO线程主要负责处理这些IO请求的回调。其中，读线程（Read thread）
    默认4个，负责读操作；写线程（Write thread）默认4个，负责写操作；日志线程（Log thread）默认1个，负责将日志缓冲区刷新到磁盘；插入缓冲区线程（Insert
    buffer thread）默认1个，负责将写缓冲区内容刷新到磁盘 。

  - **Purge Thread（清除线程）**：主要用于回收事务提交后不再使用的undo日志。事务提交后，对应的undo日志可能不再需要，Purge Thread会清理这些日志，
    释放存储空间，避免undo日志占用过多空间。

  - **Page Cleaner Thread（页清理线程）**：协助Master Thread将脏页刷新到磁盘，分担Master Thread的工作负荷，减少其工作压力，降低出现阻塞的可能性，
    从而提升数据库的整体性能和响应速度 */


-- 查看innodb引擎状态信息
show engine innodb status ;



-- 事务原理：
/*- **事务定义**：事务是一组操作的集合，构成一个不可分割的工作单元。在执行时，事务内所有操作作为一个整体向系统提交或撤销，即这些操作要么全部成功执行，
    使数据达到预期状态；要么全部失败，数据保持事务开始前的状态，以此保证数据的完整性和一致性 。

 - **事务特性（ACID）**：
    - **原子性（Atomicity）**：强调事务的不可分割性，事务中的操作要么都完成，要么都不完成，不会出现部分操作成功、部分操作失败的中间状态。
      比如转账事务，要么从一个账户成功扣款并在另一个账户成功入账，要么两个操作都不执行。

    - **一致性（Consistency）**：事务执行前后，数据库的完整性约束没有被破坏，所有数据都处于一致状态。例如，在转账事务中，转账前后两个账户的总金额应保持不变。

    - **隔离性（Isolation）**：数据库通过隔离机制，确保多个并发事务之间相互独立，一个事务的执行不会受到其他事务的干扰。不同的隔离级别（如读未提交、
      读已提交、可重复读、串行化）对事务间的隔离程度有所不同 。

    - **持久性（Durability）**：事务一旦提交，其对数据库所做的更改会永久保存，即使系统出现故障（如断电、崩溃）也不会丢失 。 */



-- 数据库事务ACID特性及其实现机制：
/*  **原子性、一致性、持久性的实现**：通过重做日志（redo log）和撤销日志（undo log）来保障。
       **undo log**：记录事务对数据修改前的状态，当事务需要回滚时，利用undo log恢复数据，保证原子性，即事务中的操作要么全成功，要么全失败。同时在事务执行过程中出现异常时，能使数据回到事务开始前的一致状态，有助于实现一致性。
       **redo log**：记录事务对数据的修改操作，事务提交后，即便系统故障，重启时也能依据redo log将数据恢复到事务提交后的状态，实现持久性，确保事务对数据库的更改永久有效。
   **隔离性的实现**：依靠锁机制和多版本并发控制（MVCC）。
       **锁机制**：在事务操作数据时，通过对数据加锁（如行锁、表锁等），阻止其他事务同时对同一数据进行冲突操作，保证事务在独立环境下运行，避免并发事务之间的干扰。
       **MVCC**：为每个数据版本维护多个版本，不同事务可以根据自身的时间戳或事务ID访问合适的数据版本，使得读操作与写操作尽可能并行，在保证数据一致性的同时，提高数据库的并发性能，实现事务的隔离性 。*/



-- 介绍重做日志（redo log）的基础上，引入了预写日志（WAL，Write-Ahead Logging）的概念：
/*   **重做日志的作用及构成**：重做日志记录事务提交时数据页的物理修改，用于实现事务的持久性。它由内存中的重做日志缓冲（redo log buffer）和磁盘上的重做日志文件
      （redo log file，如`ib_logfile0`、`ib_logfile1`）组成。事务提交时，操作产生的数据页变化信息先存到重做日志缓冲，再刷新到重做日志文件。
   **WAL机制**：即预写日志机制。图中体现的是，在将缓冲池（Buffer Pool）中的脏页刷新到磁盘数据文件（如`xxx.ibd`）过程中，可能会出现错误（用红色叉号表示）。
      基于WAL机制，会先将事务的修改信息记录到重做日志中，之后再进行数据页的持久化。这样即使在刷新脏页时出错，也能依据重做日志文件中的信息进行数据恢复，
      确保事务提交的数据不会丢失，是实现事务持久性的重要手段 。 */



-- 数据库事务中的回滚日志（undo log）相关知识：
/*  - **作用**：
    - 提供回滚功能，记录数据被修改前的信息。当事务执行过程中需要回滚（rollback）时，可依据undo log中的逻辑记录恢复数据。例如，删除记录时，
      undo log记录对应插入记录；更新记录时，记录相反的更新记录。
    - 用于多版本并发控制（MVCC），帮助事务在并发场景下访问到合适的数据版本。
  - **与重做日志区别**：undo log是逻辑日志，记录的是对数据操作的逻辑反向信息，和记录物理日志的重做日志（redo log）不同。
  - **生命周期与存储**：
    - undo log在事务执行时产生，事务提交时不会立即删除，因为可能还需用于MVCC。
    - undo log采用段的方式管理和记录，存放在回滚段（rollback segment）中，一个回滚段内部包含1024个undo log segment 。*/




-- MVCC（多版本并发控制）及其相关的当前读、快照读概念：
/* - **当前读**：读取记录的最新版本，为保证其他并发事务不能修改当前记录，会对读取的记录加锁。日常操作中，`select ... lock in share mode`（共享锁）、
     `select ... for update`、`update`、`insert`、`delete`（排他锁）都属于当前读。
   - **快照读**：简单的不加锁的`select`操作就是快照读，读取的是记录数据的可见版本，可能是历史数据，属于非阻塞读。在不同事务隔离级别下表现不同：
     - **读已提交（Read Committed）**：每次执行`select`都会生成一个快照读。
     - **可重复读（Repeatable Read）**：开启事务后，第一个`select`语句触发快照读。
     - **串行化（Serializable）**：快照读会退化为当前读。
   - **MVCC**：即多版本并发控制，通过维护数据的多个版本，使读写操作无冲突。快照读是MySQL实现MVCC的非阻塞读功能。MVCC的实现依赖于数据库记录中的三个
     隐式字段（用于标识版本等信息）、undo log日志（记录数据修改前的版本）以及readView（用于判断数据版本的可见性） 。 */


### 当前读语句
-- 1. 使用共享锁的查询：
SELECT * FROM table_name WHERE condition lock in share mode;
-- 这条语句会查询满足条件的数据，同时加上共享锁，其他事务可以对这些数据进行读操作，但不能进行写（修改、删除、插入）操作。

-- 2. 使用排他锁的查询：
SELECT * FROM table_name WHERE condition for update;
-- 此语句查询满足条件的数据并加上排他锁，其他事务既不能读也不能写这些数据，常用于需要保证数据一致性的场景，比如库存扣减前的查询 。

### 快照读语句
-- 1. 简单的全表查询：
SELECT * FROM table_name;
-- 在支持MVCC（多版本并发控制） 的数据库（如InnoDB）中，若事务隔离级别为读已提交或可重复读，该语句是快照读，读取数据的可见版本，不会对数据加锁。

-- 2. 带条件的查询：
SELECT column1, column2 FROM table_name WHERE some_column = 'value';
-- 同样在支持MVCC的环境下，这也是一个快照读语句，按条件查询数据，不阻塞其他事务对数据的操作 。


-- 非阻塞读
-- 非阻塞读是数据库读取操作中的一种特性，能提升数据库并发性能，以下是具体介绍：
/*
- **定义**：指读取操作不会阻止其他事务对相同数据的访问，即读操作与其他读写操作可以同时进行，不会相互阻塞。在这种模式下，读取数据时不会对数据加锁
  （或者使用特殊机制避免加锁带来的阻塞），从而减少了事务之间的等待时间。
- **实现方式**：常基于多版本并发控制（MVCC）实现。数据库为数据维护多个版本，读操作获取的是特定时间点的历史版本数据，而不是最新版本，这样就无需对数据
  加锁，其他事务仍可对最新版本数据进行写操作。例如在InnoDB存储引擎中，快照读就是一种非阻塞读，它通过MVCC从undo log中获取历史版本数据，实现读操作和写操作的并行。
- **优势**：极大提高数据库的并发处理能力，减少事务之间的锁冲突和等待时间，尤其适用于读多写少的业务场景，如新闻资讯网站的数据展示、电商平台的商品浏览等，
  大量的读操作不会阻塞写操作（如商品信息更新），保证系统的流畅运行 。
- **局限**：由于读取的可能不是最新数据，在对数据实时性要求极高的场景（如金融交易中的账户余额查询）不适用；并且MVCC机制需要额外空间存储数据的多个版本，会增加存储开销 。 */


-- 阻塞读
-- 阻塞读是数据库读取操作的一种类型，和非阻塞读相对，以下是详细介绍：
/*
- **定义**：指在读取数据时，若数据正被其他事务占用（比如被加锁修改），当前读取操作会被阻塞，处于等待状态，直到占用数据的事务释放相关资源（如锁）后，
  才能继续执行读取操作。这种方式能确保读取到的数据的一致性和完整性，但可能会导致事务间的等待和性能开销。
- **实现机制**：通常与数据库的锁机制紧密相关。当执行当前读操作（例如`select ... lock in share mode`、`select ... for update`等）时，会对
  数据加锁。如果此时有其他事务想要读取或修改已被锁定的数据，就会被阻塞。比如一个事务对某行数据加了排他锁进行更新操作，其他事务若要读取或修改该行数据，其操作就会被阻塞，直至排他锁被释放 。
- **应用场景**：适用于对数据一致性要求极高的场景，如银行转账、证券交易等。在这些场景中，确保数据在读取和处理过程中不被其他事务干扰至关重要，虽然可能会
  牺牲一定的并发性能，但能避免出现数据不一致、丢失更新等问题 。 */



-- MVCC（多版本并发控制）的实现原理中记录的隐藏字段
/*- MVCC是一种在数据库管理系统中用于提高并发性能的技术。在数据库的表记录中，除了用户定义的字段（如图片中的id、age、name）外，还有一些隐藏字段：
  - **DB_TRX_ID**：用于记录最近插入或最后一次修改该记录的事务ID。这有助于在并发事务中判断数据的可见性，当一个事务读取数据时，可以根据该事务ID和当前活跃事务列表来确定是否能看到这条记录的最新版本。
  - **DB_ROLL_PTR**：即回滚指针，它指向这条记录的上一个版本，结合undo log（回滚日志），在事务回滚时可以恢复到之前的数据版本，同时在读取数据时，如果当前版本不可见，也可以通过该指针获取历史版本数据。
  - **DB_ROW_ID**：这是一个隐藏主键，当表结构中没有用户指定的主键时，数据库会自动生成这个字段，用于唯一标识每一条记录。 */



-- undo log原理
/* - **undo log定义**：undo log即回滚日志，是在数据库执行`insert`、`update`、`delete`操作时产生的日志 ，主要作用是支持数据回滚。
 - **不同操作下特性**
    - **insert操作**：产生的undo log日志仅在事务回滚时需要，事务提交后可立即删除。因为插入操作在回滚时只需撤销插入动作，提交后该日志无其他用途。
    - **update和delete操作**：产生的undo log日志不仅用于回滚，还在快照读时需要，不会立即删除 。这是因为更新和删除操作涉及的数据版本在快照读场景下可能被其他事务访问，需保留日志来获取历史版本数据。*/

-- undo log版本链
/* - **事务操作示例**：图中展示了事务2、事务3、事务4、事务5对id为30记录的不同操作。事务2先修改`age`为3，事务3修改`name`为A3 ，事务4又修改`age`为10，各事务穿插提交和查询操作。
 - **版本链形成**：不同事务对同一条记录修改，会使该记录的undo log生成记录版本链表。链表头部是最新旧记录，尾部是最早旧记录。如右侧图示，通过
  `DB_ROLL_PTR`（回滚指针）串联不同版本记录，可根据事务需求追溯数据历史版本，实现MVCC下数据的多版本管理和并发控制 。*/







-- MVCC中ReadView相关内容整理
-- 一、ReadView定义
/*ReadView（读视图）是快照读 SQL 执行时，MVCC 提取数据的依据，用于记录并维护系统当前活跃（未提交）的事务 ID。*/

-- 二、ReadView核心字段
/*
| 字段          | 含义                                 |
|---------------|--------------------------------------|
| m_ids         | 当前活跃的事务 ID 集合               |
| min_trx_id    | 最小活跃事务 ID                      |
| max_trx_id    | 预分配事务 ID（当前最大事务 ID + 1，因事务 ID 自增） |
| creator_trx_id| ReadView 创建者的事务 ID             |  */

-- 三、版本链数据访问规则
/*通过以下规则判断事务是否可访问数据版本（trx_id 为当前记录的事务 ID）：
1. **`trx_id == creator_trx_id`**：可访问，说明数据是当前事务修改的。
2. **`trx_id < min_trx_id`**：可访问，说明数据已提交。
3. **`trx_id > max_trx_id`**：不可访问，说明事务在 ReadView 生成后才开启。
4. **`min_trx_id ≤ trx_id ≤ max_trx_id`**：若 `trx_id` 不在 `m_ids` 中，可访问，说明数据已提交。  */
-- 四、不同隔离级别下 ReadView 生成时机
/*- **READ COMMITTED（读已提交）**：事务中每次执行快照读时，生成新的 ReadView。
- **REPEATABLE READ（可重复读）**：仅在事务中第一次执行快照读时生成 ReadView，后续复用该 ReadView。*/







-- MVCC 中 ReadView 在 **READ COMMITTED（RC，读已提交）** 隔离级别下的工作逻辑：
/*1. **事务操作与版本链**：
   - 事务 2、3、4、5 对 id 为 30 的记录进行修改（如改 age、name）和查询，生成 undo log 版本链，通过 `DB_ROLL_PTR` 串联不同历史版本。
2. **ReadView 生成特性**：
   - RC 隔离级别下，每次快照读都会生成新的 ReadView。图中展示了两次 ReadView 的核心字段（如 `m_ids` 活跃事务集合、`min_trx_id` 最小活跃事务 ID 等）。
3. **数据访问规则应用**：
   - 通过对比记录的 `DB_TRX_ID`（图中标记为 `trx_id`）与 ReadView 字段（如 `creator_trx_id`、`min_trx_id`、`max_trx_id`、`m_ids`），判断数据版本是否可访问。例如：
     - 若 `trx_id == creator_trx_id`（当前事务修改），可访问；
     - 若 `trx_id < min_trx_id`（事务已提交），可访问；
     - 最终通过规则过滤，实现 RC 隔离级别下基于 MVCC 的数据读取控制。*/

--  实际上是记录和undo log一起参与，先从头部开始，也就是DB_TRX_ID数字大的先开始，一条一条记录的带入快照要求
-- 若四个要求都不符合，那就往下继续检索，直到有一个满足某一条要求的出现





-- **REPEATABLE READ（RR，可重复读）隔离级别** 下 MVCC 中 ReadView 的工作机制：
/*- **ReadView 生成规则**：在 RR 隔离级别下，事务中仅第一次执行快照读时生成 ReadView，后续快照读复用该 ReadView，而非每次生成新的。
- **示例说明**：
  - 图中呈现了事务 2、3、4、5 对数据的操作（修改、查询等），以及对应生成的 ReadView。首次快照读生成包含 `m_ids`（活跃事务集合）、`min_trx_id`、`max_trx_id`、`creator_trx_id` 等字段的 ReadView，后续复用该 ReadView，确保同一事务多次快照读时，基于相同的读视图判断数据可见性，实现“可重复读”的隔离效果。
- **核心作用**：通过复用 ReadView，保证事务在执行过程中，多次读取的数据版本一致，避免其他事务提交的修改被本事务看到，满足可重复读的隔离级别需求。*/




-- 总结

### 1. 逻辑存储结构
- **表空间**：数据库中最大的逻辑存储单位，可包含多个段 ，用于存储数据库对象相关数据。
- **段**：如数据段、索引段等，是表空间内的逻辑划分，用于管理特定类型的数据。
- **区**：由连续页组成，是数据库空间分配的基本单位，用于提高空间分配效率。 
- **页**：数据库 I/O 的基本单位，通常固定大小（如 InnoDB 中一般为 16KB），存储表记录等数据。
- **行**：即表中的记录，存储具体的业务数据。

### 2. 架构
- **内存结构**：包含缓冲池（Buffer Pool，缓存数据页和索引页等）、日志缓冲（redo log buffer 等，暂存日志数据）等，用于加速数据库读写操作 。
- **磁盘结构**：存放数据库文件，如数据文件（存储表数据等）、日志文件（redo log、undo log 等），是数据持久化存储的地方。 

### 3. 事务原理
- **原子性**：通过 undo log 实现。undo log 记录事务执行过程中对数据的修改操作，回滚时依据它恢复数据到事务开始前状态，保证事务操作要么全部执行，要么全部不执行。 
- **持久性**：借助 redo log 达成。redo log 记录数据修改操作，数据库重启或异常时，可依据它将已提交但未持久化到磁盘的数据重新写入磁盘，保证已提交事务数据不丢失。 
- **一致性**：由 undo log 和 redo log 共同保障。undo log 用于事务回滚维持数据一致性，redo log 用于故障恢复确保数据持久化正确，二者协作保证事务执行前后数据状态符合预期。 
- **隔离性**：依靠锁机制（如共享锁、排他锁等）和 MVCC（多版本并发控制）实现。锁机制可对数据加锁，限制并发事务访问；MVCC 基于记录隐藏字段、undo log 版本链、readView 等，在不同事务并发访问时，为事务提供数据的一致性视图，减少锁争用，提升并发性能。

### 4. MVCC
- **记录隐藏字段**：如 DB_TRX_ID（记录最近修改事务 ID）、DB_ROLL_PTR（回滚指针，指向记录上一版本）、DB_ROW_ID（隐藏主键，表无指定主键时生成） ，为 MVCC 实现提供基础数据标识。
- **undo log版本链**：不同事务对同条记录修改时，undo log 生成版本链表，记录数据历史版本，通过回滚指针串联，用于数据回滚和快照读获取历史版本数据。 
- **readView**：快照读时 MVCC 提取数据依据，记录并维护系统当前活跃（未提交）事务 ID，通过其核心字段（m_ids、min_trx_id、max_trx_id、creator_trx_id）及版本链数据访问规则，判断事务对数据版本的可见性。 
