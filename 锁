/*
锁

概述

介绍
锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU、RAM、I/0)的争用以外，数据也是
一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访
问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

分类
MySQL中的锁，按照锁的粒度分，分为以下三类:
1.全局锁:锁定数据库中的所有表。
2.表级锁:每次操作锁住整张表。
3.行级锁:每次操作锁住对应的行数据。
*/



/*全局锁
介绍
全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都
将被阻塞。
其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性*/



/*这张图主要展示了MySQL数据库备份过程中的锁机制及相关操作，以下为你详细整理：

### 1. 涉及的关键概念和命令
- **`mysqldump`**：MySQL提供的一个用于数据库备份的实用程序。图中`mysqldump -uroot -p1234 itcast > itcast.sql`命令表示以`root`用户身份（密码为`1234`）备份名为`itcast`的数据库，并将备份结果输出到`itcast.sql`文件中。
- **`flush tables with read lock`**：这是一个MySQL语句，作用是刷新表并对表加读锁。加读锁后，允许其他会话读取表中的数据（对应图中的DQL，即数据查询语言操作），但会阻止数据写入（DML，数据操作语言操作）和表结构更改（DDL，数据定义语言操作），确保备份过程中数据的一致性。
 - **`unlock tables`**：用于释放之前通过`flush tables with read lock`添加的锁，恢复表的正常读写操作。

### 2. 备份流程
 - 首先执行`flush tables with read lock`对相关表加读锁，此时数据库进入一个相对静止的状态，防止在备份过程中数据被修改或表结构被变更。
 - 接着使用`mysqldump`命令进行数据库备份，将`itcast`数据库的数据和结构导出到`itcast.sql`文件中。
 - 备份完成后，执行`unlock tables`解锁表，让数据库恢复到正常的读写状态，其他会话又可以进行DML和DDL操作。

### 3. 不同SQL操作类型
 - **DML（Data Manipulation Language）**：数据操作语言，主要用于对数据库中的数据进行增、删、改操作，如`INSERT`、`DELETE`、`UPDATE`语句。在图中加读锁的情况下，这类操作会被阻塞。
 - **DDL（Data Definition Language）**：数据定义语言，用于定义和管理数据库对象，例如创建、修改或删除表、索引等，如`CREATE TABLE`、`ALTER TABLE`、`DROP INDEX`等语句。加读锁时，这类操作同样会被阻止。
 - **DQL（Data Query Language）**：数据查询语言，用于从数据库中查询数据，最典型的是`SELECT`语句。加读锁期间，DQL操作仍可进行。 */



flush tables with read lock ;

insert into student values (15,'Jack',null); -- 无法插入，因为上一句已经锁住了数据库itcast中的表


unlock tables ;

create database itcast01;

/*### 全局锁
#### 特点
在数据库中添加全局锁是一项较为重量级的操作，存在以下问题：
- **主库备份情况**：若在主库上进行备份，备份期间无法执行更新操作，这将导致业务基本处于停滞状态。
- **从库备份情况**：若在从库上备份，备份期间从库无法执行主库同步过来的二进制日志（binlog），进而引发主从延迟问题。

#### InnoDB引擎的解决方案
在InnoDB引擎中，可在备份时添加`--single-transaction`参数，以实现不加锁的一致性数据备份。示例命令如下：
```bash
mysqldump --single-transaction -uroot -p123456 itcast > itcast.sql
```
其中，`-uroot`表示使用root用户登录，`-p123456` 是密码（实际使用时根据情况修改），`itcast`是要备份的数据库名，备份结果将输出到`itcast.sql`文件中。 */





/*### 表级锁
#### 介绍
表级锁是指在数据库操作中，每次会锁定整张表。由于其锁定粒度较大，所以发生锁冲突的概率最高，相应地，并发处理能力最低。该类型的锁应用于MyISAM、InnoDB、BDB等多种存储引擎中。

#### 分类
表级锁主要分为以下三类：
1. **表锁**：直接对整张表进行锁定，限制其他事务对该表的访问。
2. **元数据锁（meta data lock，MDL）** ：用于保护数据库对象的元数据，如在对表结构进行修改时，会使用MDL防止其他事务同时进行冲突操作。
3. **意向锁**：用于表示事务对表中数据行加锁的意图，分为意向共享锁和意向排他锁，可减少表级锁和行级锁之间的冲突检测开销 。 */




/*表锁
这张图片介绍了MySQL中的表级锁，具体内容如下：

### 表锁分类
- **表共享读锁（read lock）**：使用 `lock tables 表名 read;` 语句加锁。加锁后，允许其他会话执行数据查询语言（DQL）操作，即对表进行读取操作；但会阻止数据定义语言（DDL）和数据操作语言（DML）操作，也就是不允许对表进行结构修改和数据的增删改操作。释放锁可以使用 `unlock tables;` 语句，或者断开客户端连接。
- **表独占写锁（write lock）**：通过 `lock tables 表名 write;` 语句加锁。加锁后，当前会话可对表进行读写（DQL、DDL、DML）操作，其他会话的所有操作（DQL、DDL、DML）都会被阻塞。同样，使用 `unlock tables;` 语句或断开客户端连接来释放锁。

### 语法总结
- **加锁**：`lock tables 表名... read/write`，其中 `read` 表示加读锁，`write` 表示加写锁。
- **释放锁**：`unlock tables` 或者断开客户端连接。 */




/*
元数据：表结构
元数据锁：保护表结构，事务没提交，不能修稿表结构


这张图片介绍了MySQL中的表级锁之元数据锁（MDL），内容如下：

### 元数据锁概述
- MDL加锁由系统自动控制，无需手动使用，访问表时自动添加。其主要作用是维护表元数据的一致性，当表存在活动事务时，禁止对元数据进行写入操作，避免数据操作语言（DML）与数据定义语言（DDL）冲突，保证读写的正确性。
- 在MySQL 5.5版本引入MDL，进行表的增删改查操作时加MDL读锁（共享）；进行表结构变更操作时加MDL写锁（排他）。

### 不同SQL对应的锁类型及说明
| 对应SQL | 锁类型 | 说明 |
| --- | --- | --- |
| `lock tables xxx read / write` | `SHARED_READ_ONLY / SHARED_NO_READ_WRITE` | - |
| `select`、`select ... lock in share mode` | `SHARED_READ` | 与`SHARED_READ`、`SHARED_WRITE`兼容，与`EXCLUSIVE`互斥 |
| `insert`、`update`、`delete`、`select ... for update` | `SHARED_WRITE` | 与`SHARED_READ`、`SHARED_WRITE`兼容，与`EXCLUSIVE`互斥 |
| `alter table ...` | `EXCLUSIVE` | 与其他的MDL都互斥 |

兼容意味着可以同时存在这些锁；互斥则表示同一时间不能同时存在这些锁，否则会产生锁冲突 。
*/




select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks ;

/*这是一条用于查看MySQL中元数据锁（MDL）信息的SQL语句，各部分解析如下：
- **`select`**：SQL中的查询关键字，用于从指定表中获取数据。
- **`object_type,object_schema,object_name,lock_type,lock_duration`**：指定要查询的列。
    - `object_type`：表示被锁定对象的类型，比如表。
    - `object_schema`：对象所属的数据库模式（即数据库名）。
    - `object_name`：被锁定对象的名称，如表名。
    - `lock_type`：锁的类型，例如共享读锁、排他写锁等。
    - `lock_duration`：锁的持续时间相关信息。
- **`from performance_schema.metadata_locks`**：指定从`performance_schema`数据库中的`metadata_locks`表查询数据，该表存储了元数据锁相关的信息。

执行此SQL语句后，能获取到当前MySQL实例中关于元数据锁的相关详细信息，帮助数据库管理员分析和排查与元数据锁有关的性能问题或锁冲突问题。 */



/*这张图片介绍了MySQL中InnoDB存储引擎里表级锁中的意向锁：
- **引入目的**：在数据库操作中，数据操作语言（DML）执行时可能会添加行锁，而表级别的操作又会涉及表锁，为避免这两种锁之间产生冲突，InnoDB引入意向锁。
- **作用原理**：意向锁的存在使得在进行表锁操作时，无需逐行检查每行数据是否已被加锁，减少了表锁检查的工作量，从而提升数据库加锁操作的效率，避免不必要的资源消耗和性能损耗。

这张图片介绍了InnoDB存储引擎中意向锁的两种类型及其添加方式：
- **意向共享锁（IS）**：当执行 `select... lock in share mode` 语句时添加。该语句用于对查询结果添加共享锁，此时会自动添加意向共享锁，表明事务
后续有获取某些行共享锁的意向，允许其他事务对相同行获取共享锁，但不允许获取排他锁。
- **意向排他锁（IX）**：由 `insert`（插入）、`update`（更新）、`delete`（删除）、`select... for update` 语句添加。这些操作通常需要对数据
行进行独占访问，添加意向排他锁意味着事务后续有获取某些行排他锁的意向，会阻止其他事务对相同行获取共享锁或排他锁 。

这张图片进一步介绍了InnoDB存储引擎中意向锁的兼容性，以及查看意向锁和行锁加锁情况的SQL语句：

### 意向锁兼容性
- **意向共享锁（IS）**：与表锁共享锁（read）兼容，意味着可以同时存在意向共享锁和表锁共享锁；与表锁排他锁（write）互斥，即不能同时存在意向共享锁和表锁排他锁。
- **意向排他锁（IX）**：与表锁共享锁（read）及表锁排他锁（write）都互斥，也就是意向排他锁存在时，表锁共享锁和表锁排他锁都不能同时存在。另外，意向锁之间不会互斥，不同事务的意向共享锁或意向排他锁可以同时存在。

### 查看加锁情况的SQL语句
```sql*/
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
/*```
各部分解析：
- `select`：查询关键字。
- `object_schema,object_name,index_name,lock_type,lock_mode,lock_data`：要查询的列。
    - `object_schema`：对象所属的数据库模式（即数据库名）。
    - `object_name`：被锁定对象的名称，如表名。
    - `index_name`：涉及的索引名称。
    - `lock_type`：锁的类型，如意向锁、行锁等。
    - `lock_mode`：锁的模式，如共享、排他等。
    - `lock_data`：被锁定的数据相关信息。
- `from performance_schema.data_locks`：指定从`performance_schema`数据库中的`data_locks`表查询数据，通过执行该语句可以获取当前数据库中意向锁及行锁的加锁情况 。 */


begin ;
select * from student where id = 1 lock in share mode ;
commit; -- 手动提交事务，不然完成时间太快了

select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks; -- 查询加的锁
lock tables student read ;-- 加表共享读锁
lock tables student write ; -- 加表独占写锁，会与意向共享锁排斥，加不上去，
-- 在可视化界面操作时，并不算真正的并发，所以能插入成功，还是有一定的先后顺序了，系统会自动帮我们提交未提交的事务，然后加独占写锁
-- 可以用两个或多个命令行模拟并发情况，那样的哈，会出现插入冲突

unlock tables ;


begin ;
insert into student values (16,'JJJ',null); -- 自动加上意向排他锁
commit ;

SHOW VARIABLES LIKE 'performance_schema';


-- 这张图片介绍了MySQL中InnoDB存储引擎的行级锁，内容如下：
-- 行级锁
/*### 行级锁概述
行级锁每次操作只锁住对应的行数据，锁定粒度最小，因此锁冲突概率最低，并发度最高。InnoDB的数据基于索引组织，行锁通过对索引项加锁实现，而非直接对记录加锁。

### 行级锁分类
- **行锁（Record Lock）**：锁定单个行记录，防止其他事务对该行进行更新（update）和删除（delete）操作。在读已提交（RC）和可重复读（RR）隔离级别下都支持。
- **间隙锁（Gap Lock）**：锁定索引记录之间的间隙（不包含记录本身），确保索引记录间隙不变，防止其他事务在此间隙插入数据，从而避免幻读问题。仅在可重复读（RR）隔离级别下支持。
- **临键锁（Next-Key Lock）**：是行锁和间隙锁的组合，既锁定数据行，又锁定数据行前面的间隙。同样仅在可重复读（RR）隔离级别下支持 。

图片下方的示例图展示了索引记录的分布，以及加锁的位置示意，帮助理解间隙锁和临键锁对索引间隙和记录的锁定范围。 */



/*这张图片介绍了InnoDB存储引擎中的两种行锁类型及其兼容性：

### 行锁类型
- **共享锁（S）**：事务获取共享锁后可以读取对应行数据，并且会阻止其他事务获取相同数据集的排他锁，从而保证读取数据时数据不被修改。
- **排他锁（X）**：获取排他锁的事务可以对数据进行更新操作，同时会阻止其他事务获取相同数据集的共享锁和排他锁，以确保数据更新时的独占性。

### 锁兼容性
| 当前锁类型 \ 请求锁类型 | S（共享锁） | X（排他锁） |
| --- | --- | --- |
| S（共享锁） | 兼容，即多个事务可以同时对同一数据集持有共享锁，实现并发读  | 冲突，当已有事务持有共享锁时，其他事务不能获取排他锁  |
| X（排他锁） | 冲突，当已有事务持有排他锁时，其他事务不能获取共享锁  | 冲突，同一时刻只能有一个事务对同一数据集持有排他锁  | */



/*这张图片展示了InnoDB存储引擎中不同SQL语句对应的行锁类型及加锁方式，具体如下：
- **INSERT、UPDATE、DELETE语句**：执行这些语句时，会自动添加排他锁（X锁），以确保在插入、更新或删除数据时，其他事务不能同时操作相同的数据行，保证数据的一致性和完整性。
- **SELECT（正常）语句**：普通的SELECT查询不会自动添加任何锁，多个事务可以同时读取数据，不会相互阻塞。
- **SELECT ... LOCK IN SHARE MODE语句**：需要手动在SELECT后添加`LOCK IN SHARE MODE`，此时会添加共享锁（S锁），允许事务读取数据，并且可以阻止其他事务获取相同数据集的排他锁。
- **SELECT ... FOR UPDATE语句**：需手动在SELECT后加上`FOR UPDATE`，该语句会添加排他锁（X锁），获取锁的事务可以更新数据，同时阻止其他事务获取相同数据集的共享锁和排他锁。 */

/*这张图片主要介绍了InnoDB存储引擎在行锁方面的特性及相关优化和变化情况：
- **默认事务隔离级别与锁类型**：InnoDB默认在可重复读（REPEATABLE READ）事务隔离级别下运行，此时会使用临键锁（next-key lock）进行索引扫描，防止
幻读问题。这是因为在可重复读隔离级别中，需要避免在一个事务内多次读取数据时出现新插入数据（幻读）的情况，临键锁能锁定数据及其前面的间隙。
- **索引等值匹配时的优化**：当针对唯一索引进行检索，并且是对已存在记录进行等值匹配（如`SELECT * FROM table WHERE unique_key = 'value'`，
`unique_key`为唯一索引）时，InnoDB会自动将临键锁优化为行锁。这是因为唯一索引能准确定位记录，不需要锁定间隙，从而减少锁的范围，提升并发性能。
- **无索引条件检索的情况**：InnoDB的行锁是基于索引添加的，如果查询数据时没有通过索引条件（例如全表扫描且无索引可用的情况），InnoDB会对表中的所有记
录加锁，此时行锁就会升级为表锁。这会极大降低并发度，因为表锁会阻止其他事务对整个表进行操作，所以在设计数据库和编写SQL时，应尽量保证查询能利用索引 。 */



select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
/*这是一条用于查看MySQL中意向锁及行锁加锁情况的SQL语句，各部分解析如下：
- `select`：是SQL的查询关键字，用于指定要从表中检索数据。
- `object_schema,object_name,index_name,lock_type,lock_mode,lock_data`：这些是要查询的列。
    - `object_schema`：表示被加锁对象所属的数据库模式（即数据库名）。
    - `object_name`：被加锁对象的名称，通常是表名。
    - `index_name`：与锁相关的索引名称，如果有的话。
    - `lock_type`：锁的类型，如意向共享锁、意向排他锁、行锁等。
    - `lock_mode`：锁的模式，比如共享模式、排他模式等。
    - `lock_data`：关于被锁定数据的相关信息。
- `from performance_schema.data_locks`：指定从`performance_schema`数据库中的`data_locks`表获取数据，该表记录了数据库中各类数据锁（包括意向锁和行锁）的相关信息。

执行这条SQL语句后，就能获取到当前数据库中关于意向锁及行锁的加锁情况，帮助排查锁相关的性能问题或冲突。 */


-- 对id=1加了行锁，如果对id=3进行增删改，添加排他锁，都可以，因为加的是行级锁

show index from student;


/*这张图片主要讲解了InnoDB存储引擎行锁的相关知识：
- **默认事务隔离级别与锁策略**：InnoDB默认运行在可重复读（REPEATABLE READ）事务隔离级别，使用临键锁（next-key lock）进行索引扫描和搜索，目的
  是防止幻读。因为在可重复读隔离级别下，一个事务多次读取数据时，需要避免其他事务在两次读取之间插入新数据，临键锁能锁定数据及其前面的间隙，从而避免幻读
  情况发生。

- **行锁优化情况**：当针对唯一索引进行等值匹配（即精确查找已存在记录，如`SELECT * FROM table WHERE unique_key = 'value'`，`unique_key`
  是唯一索引）检索时，InnoDB会自动将临键锁优化为行锁。这是由于唯一索引能精准定位记录，无需锁定间隙，减少了锁的范围，提高并发性能。

- **锁升级情况**：InnoDB的行锁基于索引添加。若检索数据时不通过索引条件（例如全表扫描且无合适索引可用），InnoDB会对表中的所有记录加锁，行锁就会升
  级为表锁。表锁会降低并发度，因为它会阻止其他事务对整个表进行操作，所以设计数据库和编写SQL时，要尽量让查询利用索引。

- **查看锁信息的SQL**：提供了查看意向锁及行锁加锁情况的SQL语句 `select object_schema,object_name,index_name,lock_type,lock_mode,
  lock_data from performance_schema.data_locks;`，通过执行该语句，可以从`performance_schema`数据库的`data_locks`表中获取被锁定对象
  所属模式、对象名、索引名、锁类型、锁模式以及被锁定数据相关信息，用于排查锁相关问题。 */



/*这张图片主要介绍了InnoDB存储引擎中，在可重复读（REPEATABLE READ）事务隔离级别下，间隙锁和临键锁的相关特性及演示情况：
- **间隙锁和临键锁的使用背景**：默认情况下，InnoDB在可重复读事务隔离级别运行，为防止幻读，会使用临键锁进行搜索和索引扫描。
- **间隙锁的产生情况**：
    - 当在唯一索引上进行等值查询，且给不存在的记录加锁时，会优化为间隙锁。比如表中有索引列值为1、3、5，当查询`WHERE id = 2 FOR UPDATE`时，会对1和3之间的间隙加间隙锁。
    - 在普通索引上进行等值查询，向右遍历时最后一个值不满足查询需求时，临键锁会退化为间隙锁。例如普通索引列值为1、3、5，查询`WHERE id = 4 FOR UPDATE`，从左向右遍历到3后不满足条件，此时会在3和5之间的间隙加间隙锁。
- **临键锁的产生情况（唯一索引范围查询）** ：在唯一索引上进行范围查询时，会访问到不满足条件的第一个值为止，这个过程中会使用临键锁。比如索引列值为1、3、5，查询`WHERE id > 1 FOR UPDATE`，会对大于1的记录及对应间隙加临键锁，直到遇到不满足条件的值（若后续无记录则到索引边界）。
- **间隙锁的特性**：间隙锁的唯一目的是防止其他事务在间隙中插入数据。而且间隙锁可以共存，即一个事务加的间隙锁不会阻止另一个事务在同一间隙上加间隙锁。 */



-- 这张图片是对数据库中锁机制的总结，涵盖了锁的概述以及全局锁、表级锁、行级锁三类锁的特点：
-- **概述**：在数据库并发访问场景下，锁机制用于解决数据访问的一致性和有效性问题。主要包括全局锁、表级锁、行级锁这三种类型的锁。
/*-- **全局锁**：会对整个数据库实例加锁，加锁后数据库实例处于只读状态，其他写入操作会被阻塞。由于它会影响整个数据库的读写性能，所以性能较差，但常在进行
    数据逻辑备份时使用，确保备份过程中数据不被修改。*/
/*-- **表级锁**：操作时会锁住整张表，锁定粒度较大，因此多个事务同时操作同一张表时，发生锁冲突的概率较高。表级锁包含表锁（对整个表进行读写锁定）、元数据
锁（用于保护表结构等元数据不被并发修改）、意向锁（如意向共享锁、意向排他锁，用于表示事务后续对行锁的意向，减少表级锁检查的开销）。 */
/*-- **行级锁**：只锁住操作对应的行数据，锁定粒度最小，所以发生锁冲突的概率也最低，能提供较高的并发度。行级锁主要有行锁（锁定单个行记录，防止其他事务更
新或删除该行）、间隙锁（锁定索引记录间隙，防止其他事务插入数据产生幻读）、临键锁（行锁和间隙锁的组合，在可重复读隔离级别下用于防止幻读和保证数据一致性）*/ 
